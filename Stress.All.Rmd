---
title: "Stress2"
author: "Zachary Snider"
date: "2022-10-25"
output: html_document
editor_options: 
  chunk_output_type: console
---

## R Markdown
#Saved in github repository BoecheraStress

Stress and Climate data for Southern California Boechera populations collected by Zach Snider. Variables include: Invididual, subpopulation (PopID), regional population (Region), Temperature of heat stress experiment (Heat.Temp), Cotyledon or True Leaf measurements (Cotyledon.vs.TL), Relative time, Date of heat stress, time of heat stress, type of stress measurement, count of measurement for that session, 1:F, 1:Fm, 1:Temp, YII,, 1:Fo,, 1:Fm, 1:Fv/Fm , Latitude, Longitude, Elevation, Date.Found, mean temperature, average max temp, average min temp, average precipitation, average max vapor pressure deficit, average min vapor pressure deficit, aspect, average solar transmittance on a clear day, and average solar transmittance on a cloudy day. 

Elevation along with the 9 climate variables are potential explanatory variables, and could be appropriate for a multiple regression approach to predicting YII (quantum yield), but 10
predictors is a lot. So it may be preferable to reduce the number of explanatory
variables using PCA to come up with a few important explanatory components.

Loading in the required packages
```{r setup, include=FALSE}
library(vegan)
library(FactoMineR)
library(ggplot2)
library(ggfortify)
library(tidyverse)
library(factoextra)
library(gridExtra)
library(car)
library(leaps)
library(picante)
library(hrbrthemes)
library(plotly)
library(tibble)
library(forcats)
library(scales)
library(nlme)
library(lme4)
library(cluster)
library(modEvA)
library(poppr)
library(AICcmodavg)
library(effects)
```


Loading in the data. 
```{r}
#setwd("~/Desktop/StressExperiments")
#setwd("C:/Users/Daniel/Desktop/BoecheraStress-main")
setwd("~/Documents/GitHub/BoecheraStress")
stress <- read.csv("jrpam_all.csv")
recovery <- read.csv("jrpam_5day.csv")
climate <- read.csv("boechera_climate_data.csv")
climate$PopID <- as.factor(climate$PopID)
stress$PopID <- as.factor(stress$PopID)
recovery$PopID <- as.factor(recovery$PopID)
colnames(stress) <- c('Individual','PopID','Region','Species',
                      'Heat.Temp','Cotyledon.vs.TL',
                           'count','Date.Stress','Time.Stress','Fo.prime','No.',
                      'F','Fm.','Temp','YII','Fo','Fm','Fv.Fm')
colnames(recovery) <- c('Individual','PopID','Region','Species','Heat.Temp',
                        'Cotyledon.vs.TL', 'count','Date.Stress','Time.Stress',
                        'Fo.prime','No.', 'F','Fm.','Temp','YII','Fo','Fm','Fv.Fm')
stress.clim <- left_join(stress, climate, by=c("Individual","Region","PopID","Species"))
colnames(stress.clim) <- c('Individual','PopID','Region','Species','Heat.Temp','Cotyledon.vs.TL','count','Date.Stress','Time.Stress','Fo.prime','No.','F','Fm.','Temp','YII','Fo','Fm','Fv.Fm','Latitude','Longitude','Elevation','Date.Found','tmean','tmax','tmin','PPT','tdmean','vpdmax','vpdmin','aspect','solclear','soltrans') #Renaming columns for legibility
recovery.clim <- left_join(recovery, climate, by=c("Individual","Region","PopID","Species"))
colnames(recovery.clim) <- c('Individual','PopID','Region','Species','Heat.Temp','Cotyledon.vs.TL','count','Date.Stress','Time.Stress','Fo.prime','No.','F','Fm.','Temp','YII','Fo','Fm','Fv.Fm','Latitude','Longitude','Elevation','Date.Found','tmean','tmax','tmin','PPT','tdmean','vpdmax','vpdmin','aspect','solclear','soltrans') 
recovery.clim <- recovery.clim %>%
  filter(Heat.Temp == "44")
stress.clim <- stress.clim %>%
  filter(Heat.Temp == "44")
```


To include B arcuata, B retrofracta, and B californica, run this chunk
```{r}
stress.clim.ca <- recovery.clim %>%
  filter(Region == "Lab" | Species == "californica")
recovery.clim.ca <- stress.clim %>%
  filter(Region == "Lab" | Species == "californica")
```

To subset for only only B. californica, run this chunk
```{r}
stress.clim.ca <- stress.clim %>%
  filter(Species == "californica")
recovery.clim.ca <- recovery.clim %>%
  filter(Species == "californica")
```

To subset for True Leaves, run this chunk
```{r}
stress.clim.ca <- stress.clim.ca %>%
  filter(Cotyledon.vs.TL=="True Leaf")
recovery.clim.ca <- recovery.clim.ca %>%
  filter(Cotyledon.vs.TL=="True Leaf")
```

Creating a variance and a mean YII column
```{r}
recovery.clim.ca.var <- aggregate(YII ~ Individual + count, 
                    data=recovery.clim.ca, 
                    function(x) { 
                      c(avg=var(x)) 
                    })
colnames(recovery.clim.ca.var) <- c('Individual','count','YII.var')
recovery.clim.ca.2 <- left_join(recovery.clim.ca.var, recovery.clim.ca, by=c('Individual','count'))
recovery.clim.ca.3 <- recovery.clim.ca.2[!duplicated(recovery.clim.ca.2$count), ]
head(recovery.clim.ca.2)
recovery.clim.ca.2 <- recovery.clim.ca.2[,-c(9,10,11,12,23,31)]
recovery.clim.ca.mean <- aggregate(YII ~ Individual + count, 
                    data=recovery.clim.ca, 
                    function(x) { 
                      c(avg=mean(x)) 
                    })
colnames(recovery.clim.ca.mean) <- c('Individual','count','YII.mean')
recovery.clim.ca.2 <- left_join(recovery.clim.ca.mean, recovery.clim.ca.2, by=c('Individual','count'))
recovery.clim.ca.3 <- recovery.clim.ca.2[!duplicated(recovery.clim.ca.2$count), ]
recovery.clim.ca.3$Individual <- as.factor(recovery.clim.ca.3$Individual)
head(recovery.clim.ca.3)
recovery.clim.ca.2$Individual <- as.factor(recovery.clim.ca.2$Individual)
#write.csv(recovery.clim.ca.3,file ="Recovery.clim.ca.3.csv", row.names=FALSE)
#For the initial stress group
stress.clim.ca.var <- aggregate(YII ~ Individual + count, 
                    data=stress.clim.ca, 
                    function(x) { 
                      c(avg=var(x)) 
                    })
colnames(stress.clim.ca.var) <- c('Individual','count','YII.var')
stress.clim.ca.2 <- left_join(stress.clim.ca.var, stress.clim.ca, by=c('Individual','count'))
stress.clim.ca.3 <- stress.clim.ca.2[!duplicated(stress.clim.ca.2$count), ]
head(stress.clim.ca.2)
stress.clim.ca.2 <- stress.clim.ca.2[,-c(9,10,11,12,23,31)]
stress.clim.ca.mean <- aggregate(YII ~ Individual + count, 
                    data=stress.clim.ca, 
                    function(x) { 
                      c(avg=mean(x)) 
                    })
colnames(stress.clim.ca.mean) <- c('Individual','count','YII.mean')
stress.clim.ca.2 <- left_join(stress.clim.ca.mean, stress.clim.ca.2, by=c('Individual','count'))
stress.clim.ca.3 <- stress.clim.ca.2[!duplicated(stress.clim.ca.2$count), ]
stress.clim.ca.2$Individual <- as.factor(stress.clim.ca.2$Individual)
head(stress.clim.ca.3)
```

Adding in climatic Clusters
```{r}
clusts <- read.csv("climate.clust2.csv")
clusts$PopID <- as.factor(clusts$PopID)
recovery.clim.ca.3 <- left_join(recovery.clim.ca.3, clusts, by=c('PopID'))
recovery.clim.ca.3$Clim3 <- as.factor(recovery.clim.ca.3$Clim3)
recovery.clim.ca.3 <- recovery.clim.ca.3[!duplicated(recovery.clim.ca.3$count), ]
stress.clim.ca.3 <- left_join(stress.clim.ca.3, clusts, by=c('PopID'))
stress.clim.ca.3$Clim3 <- as.factor(stress.clim.ca.3$Clim3)
stress.clim.ca.3 <- stress.clim.ca.3[!duplicated(stress.clim.ca.3$count), ]
```


### 5 DAY RECOVERY CHLOROPHYLL FLUORESCENCE DATA ###

Recovery YII averaged for each subpop
```{r}
recoveryplot2 <- ggplot(data=recovery.clim.ca.2,aes(x=as.factor(PopID), y=as.numeric(YII), fill=as.factor(Region))) +
  geom_boxplot() +
  theme_bw(base_size=20) +
  ylab("YII") +
  xlab("Subopulation") +
  labs(title = "5 Day Recovery Measurements") +
  labs(fill="Region") +
  scale_fill_brewer(palette="Set2")
recoveryplot2
```

Nested ANOVA to test the variance of YII. 

The model is YII ~ Region + Pop(Region) + Individual(Pop(Region))
Individual is a random effect. 
```{r}
#Make the nested anova
nest_r <- aov(recovery.clim.ca.3$YII.var ~ recovery.clim.ca.3$Region / factor(recovery.clim.ca.3$PopID) / factor(recovery.clim.ca.3$Individual))
summary(nest_r)
nest_r
TukeyHSD(nest_r)$'recovery.clim.ca.3$Region'
#Nested ANOVA based on climate cluster
#nest_r2 <- aov(recovery.clim.ca.3$YII.var ~ recovery.clim.ca.3$Clim3 / factor(recovery.clim.ca.3$PopID) / factor(recovery.clim.ca.3$Individual))
#summary(nest_r2)
```
ANOVA for diploids vs polyploids
```{r}
nest_species <- aov(recovery.clim.ca.3$YII.var ~ recovery.clim.ca.3$Species)
summary(nest_species)
```

YII variance plot
```{r}
vplot <- ggplot(data=recovery.clim.ca.3, aes(x=as.factor(PopID), y=as.numeric(YII.var),
                                           fill=as.factor(Region))) +
  geom_boxplot() +
  theme_bw() +
  xlab("Population") + ylab("YII Variance") + 
  ylim(0,0.16) + 
  labs(title="5 Day Recovery", fill="Region")
vplot
```

Linear Mixed Effects Model
```{r}
recovery.clim.ca.2$Individual<- as.factor(recovery.clim.ca.2$Individual)
recovery.clim.ca.2$Region <- as.factor(recovery.clim.ca.2$Region)
recovery.clim.ca.2$PopID <- as.factor(recovery.clim.ca.2$PopID)
m <- lmer(YII ~ Region + (1|PopID) + (1|Individual), data=recovery.clim.ca.3)
summary(m)
m
anova(m)
plot(m)
0.118/(0.118+0.114+.194) #=0.28
#Individual explains 28 % of the variance left over after fixed effects are taken into account
0.194/(0.118+0.114+.194) #=0.46
#PopID explains 46% of the variance left over
#citation("lme4")
m1 <- lmer(YII ~ Clim3 + (1|PopID) + (1|Individual), data=recovery.clim.ca.3)
library(effects)
plot(allEffects(m))
plot(allEffects(m1))
confint(m)
```

Multiple Regression

Best Subsets to determine the model with the highest r squared value. 
```{r}
rmod.fit <- regsubsets(YII ~ tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data=recovery.clim.ca, nvmax=10)
sum.rmod <- summary(rmod.fit)
sum.rmod
plot(sum.rmod$adjr2,xlab = "Number of Variables", ylab = "Adjusted RSq")
adj_r2_max = which.max(sum.rmod$adjr2) #9
points(adj_r2_max, sum.rmod$adjr2[adj_r2_max], col ="red", cex = 2, pch = 20)
# Forward Stepwise Selection
#regfit_fwd = regsubsets(YII~tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data = recovery.clim.ca, nvmax = 10, method = "forward")
#summary(regfit_fwd)
# Backward Stepwise Selection
#regfit_bwd = regsubsets(YII~tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data = recovery.clim.ca, nvmax = 10, method = "backward")
#summary(regfit_bwd)
#citation("leaps")
```

Creating the multiple regression model
```{r}
rmod <- lm(YII ~ tmean + Elevation + tmax  + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data=recovery.clim.ca)
summary(rmod) #adjusted r squared = 0.2943
rmod
RSME.rmod <- sqrt(mean(rmod$residuals^2))
RSME.rmod
AIC(rmod);BIC(rmod)
#Anova(rmod, type=2)
```

Checking correlation of variables. 
```{r}
cor.table(recovery.clim.ca.2[,c(18:25,27,28)])
cor_data <- cor((recovery.clim.ca.2[,c(18:25,27,28)]))
cor_data
cor_matrix_rm <- cor_data                # Modify correlation matrix
cor_matrix_rm[upper.tri(cor_matrix_rm)] <- 0
diag(cor_matrix_rm) <- 0
cor_matrix_rm
#To remove highly correlated variables
recovery.clim.ca.4 <- recovery.clim.ca.2[ , !apply(cor_matrix_rm,2,function(x) any(x > 0.99))]
```

Plotting YII against climatic variables
```{r}
p1 <- ggplot(data=recovery.clim.ca, aes(x=tmean, y=YII)) +
  geom_point() + theme_bw() + xlab("Mean Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p2 <- ggplot(data=recovery.clim.ca, aes(x=tmax, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Max Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p3 <- ggplot(data=recovery.clim.ca, aes(x=tmin, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Min Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p4 <- ggplot(data=recovery.clim.ca, aes(x=Elevation, y=YII)) +
  geom_point() + theme_bw() +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
grid.arrange(p1, p2, p3, p4, ncol=2)
p5 <- ggplot(data=recovery.clim.ca, aes(x=PPT, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Annual Precipitation") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p6 <- ggplot(data=recovery.clim.ca, aes(x=tdmean, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Annual Dew Point Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p7 <- ggplot(data=recovery.clim.ca, aes(x=vpdmax, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Max Annual Vapor Pressure Deficit") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p8 <- ggplot(data=recovery.clim.ca, aes(x=vpdmin, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Min Annual Vapor Pressure Deficit") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p9 <- ggplot(data=recovery.clim.ca, aes(x=solclear, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Annual Solar Radiation") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p10 <- ggplot(data=recovery.clim.ca, aes(x=soltrans, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Annual Cloud Transmittance") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
grid.arrange(p5, p6, p7, p8, p9, p10, ncol=2)
#grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8,p9,ncol=3)
```

### INITIAL CHLOROPHYLL FLUORESCENCE DATA ###

Initial YII averaged for each subpop
```{r}
stressplot2 <-  ggplot(data=stress.clim.ca.2, aes(x=as.factor(PopID), y=YII, fill=as.factor(Region))) +
  geom_boxplot() +
  theme_bw() +
  ylab("YII") +
  xlab("Population") +
  labs(title = "Initial Stress Measurements") +
  labs(fill="Heat Stress (C°)") +
  scale_fill_brewer(palette="Set2")
stressplot2
```

Nested ANOVA to test the variance of YII. 
The model is YII ~ Region + Pop(Region) + Individual(Pop(Region))
Individual is a random effect. 
```{r}
#Make the nested anova
nest_s <- aov(stress.clim.ca.3$YII.var ~ stress.clim.ca.3$Region / factor(stress.clim.ca.3$PopID) / factor(stress.clim.ca.3$Individual))
summary(nest_s)
TukeyHSD(nest_s)$'stress.clim.ca.3$Region'
```

ANOVA for diploids vs polyploids
```{r}
nest_species <- aov(stress.clim.ca.3$YII.var ~ stress.clim.ca.3$Species)
summary(nest_species)
```

Linear Mixed Effects Model
```{r}
stress.clim.ca.2$Individual<- as.factor(stress.clim.ca.2$Individual)
stress.clim.ca.2$Region <- as.factor(stress.clim.ca.2$Region)
stress.clim.ca.2$PopID <- as.factor(stress.clim.ca.2$PopID)
m <- lmer(YII ~ Region + (1|PopID) + (1|Individual), data=stress.clim.ca.2)
summary(m)
m
anova(m)
plot(m)
0.1014/(0.1014+0.388+.1699) #=0.15
#Individual explains 15 % of the variance left over after fixed effects are taken into account
0.0388/(0.1014+0.388+.1699) #=0.059
#PopID explains 5.9% of the variance left over
plot(allEffects(m))
confint(m)

```
Multiple Regression

Best Subsets to determine the model with the highest r squared value. 
```{r}
smod.fit <- regsubsets(YII ~ tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data=stress.clim.ca.2, nvmax=10)
sum.smod <- summary(smod.fit)
sum.smod
plot(sum.smod$adjr2,xlab = "Number of Variables", ylab = "Adjusted RSq")
adj_r2_max = which.max(sum.smod$adjr2) #8
points(adj_r2_max, sum.smod$adjr2[adj_r2_max], col ="red", cex = 2, pch = 20)
which.max(sum.smod$bic)
```

Creating the multiple regression model
```{r}
smod <- lm(YII ~ tmean + Elevation + tmax + tdmean + vpdmax  + tmin +vpdmin + solclear + soltrans, data=stress.clim.ca.2)
summary(smod) #adjusted r squared = 0.2332
RSME.smod <- sqrt(mean(smod$residuals^2))
RSME.smod
AIC(smod);BIC(smod)
```

Plotting YII against climatic variables
```{r}
p1 <- ggplot(data=stress.clim.ca.2, aes(x=tmean, y=YII)) +
  geom_point() + theme_bw() + xlab("Mean Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p2 <- ggplot(data=stress.clim.ca.2, aes(x=tmax, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Max Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p3 <- ggplot(data=stress.clim.ca.2, aes(x=tmin, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Min Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p4 <- ggplot(data=stress.clim.ca.2, aes(x=Elevation, y=YII)) +
  geom_point() + theme_bw() +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
grid.arrange(p1, p2, p3, p4, ncol=2)
p5 <- ggplot(data=stress.clim.ca.2, aes(x=PPT, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Annual Precipitation") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p6 <- ggplot(data=stress.clim.ca.2, aes(x=tdmean, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Annual Dew Point Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p7 <- ggplot(data=stress.clim.ca.2, aes(x=vpdmax, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Max Annual Vapor Pressure Deficit") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p8 <- ggplot(data=stress.clim.ca.2, aes(x=vpdmin, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Min Annual Vapor Pressure Deficit") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p9 <- ggplot(data=stress.clim.ca.2, aes(x=solclear, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Annual Solar Radiation") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p10 <- ggplot(data=stress.clim.ca.2, aes(x=soltrans, y=YII)) +
  geom_point() + theme_bw() + xlab("Average Annual Cloud Transmittance") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
grid.arrange(p5, p6, p7, p8, p9, p10, ncol=3)
grid.arrange(p1,p2,p3,p4,p5,p6,p7,p8,p9,ncol=3)
```




### ION LEAKAGE ###

Loading in the data
```{r}
ion <- read.csv("IonLeakage.csv")
#Merging the ion leakage data and climate data
ion$Individual <- as.character(ion$Individual)
climate$Individual <- as.character(climate$Individual)
ion$PopID <- as.factor(ion$PopID)
ion.clim <- left_join(ion, climate, by=c("Individual","Region","PopID","Species"))
colnames(ion.clim) <- c('Individual','PopID','Region','Species','Date','0H','4H','Total.24.Freeze','Percent.Leaked','Latitude','Longitude','Elevation','Date.Found','tmean','tmax','tmin','PPT','tdmean','vpdmax','vpdmin','aspect','solclear','soltrans') #Renaming columns for legibility
ion.clim$Percent.Leaked <- as.numeric(ion.clim$Percent.Leaked)
ion.clim$Individual <- as.factor(ion.clim$Individual)
ion.clim$PopID <- as.factor(ion.clim$PopID)
```

To filter for californica only, run this chunk
```{r}
ion.clim.ca <- ion.clim %>%
  filter(Species == "californica")
```

To include B arcuata, B retrofracta, and B californica, run this chunk
```{r}
ion.clim.ca <- ion.clim %>%
  filter(Species == "retrofracta" | Species == "californica" | Species == "arcuata")
```

Ion Leakage plot
```{r}
ioncaplot <- ggplot(ion.clim.ca, aes(x=PopID, y=Percent.Leaked, color = Region)) +
  geom_boxplot() +
  theme_bw(base_size=20) +
  xlab("Subpopulation") +
  ylab("Percent of Ions Leaked After 4 Hours")
ioncaplot
```

Nested ANOVA to test the variance of Ion Leakage. 
The model is Ion Leakage ~ Region + Pop(Region) + Individual(Pop(Region))
Individual is a random effect. 
```{r}
#Make the nested anova
nest_i <- aov(ion.clim.ca$Percent.Leaked ~ factor(ion.clim.ca$PopID) / factor(ion.clim.ca$Individual))
summary(nest_i)
TukeyHSD(nest_i)
```

Diploid Species ANOVA
```{r}
nest_species2 <- aov(ion.clim.ca$Percent.Leaked ~ ion.clim.ca$Species)
summary(nest_species2)
TukeyHSD(nest_species2)
```
Diploid species graph
```{r}
ioncaplot <- ggplot(ion.clim.ca, aes(x=PopID, y=Percent.Leaked, color = Species)) +
  geom_boxplot() +
  theme_bw(base_size=20) +
  xlab("Subpopulation") +
  ylab("Percent of Ions Leaked After 4 Hours")
ioncaplot
```

Linear Mixed Effects Model
```{r}
mixed.lmer_i <- lmer(Percent.Leaked ~ Region + (1|PopID) + (1|Individual), data = ion.clim.ca)
summary(mixed.lmer_i)
plot(mixed.lmer_i)
qqnorm(resid(mixed.lmer_i)); qqline(resid(mixed.lmer_i))
#Variance for Individual is 6.908. Divide this by total variance. 
6.908 / (6.908 + 5.864 + 19.535) # =0.21.38
#Individual explains 21% of the variance left over after the variance explained by our fixed effects.
plot(allEffects(mixed.lmer_i))
confint(mixed.lmer_i)
```

Multiple Regression

Best Subsets to determine the model with the highest r squared value. 
```{r}
imod.fit <- regsubsets(Percent.Leaked ~ tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data=ion.clim.ca, nvmax=10)
sum.imod <- summary(imod.fit)
sum.imod
plot(sum.imod$adjr2,xlab = "Number of Variables", ylab = "Adjusted RSq")
adj_r2_max = which.max(sum.imod$adjr2) #9
points(adj_r2_max, sum.imod$adjr2[adj_r2_max], col ="red", cex = 2, pch = 20)
```

Creating the multiple regression model
```{r}
imod <- lm(Percent.Leaked ~ tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + soltrans, data=ion.clim.ca)
summary(imod) #adjusted r squared = 0.253
RSME.imod <- sqrt(mean(imod$residuals^2))
RSME.imod
AIC(imod);BIC(imod)
```

Plotting ion leakage against climatic variables
```{r}
p1 <- ggplot(data=ion.clim.ca, aes(x=tmean, y=Percent.Leaked)) +
  geom_point() + theme_bw() + xlab("Mean Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p2 <- ggplot(data=ion.clim.ca, aes(x=tmax, y=Percent.Leaked)) +
  geom_point() + theme_bw() + xlab("Average Max Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p3 <- ggplot(data=ion.clim.ca, aes(x=tmin, y=Percent.Leaked)) +
  geom_point() + theme_bw() + xlab("Average Min Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p4 <- ggplot(data=ion.clim.ca, aes(x=Elevation, y=Percent.Leaked)) +
  geom_point() + theme_bw() +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
grid.arrange(p1, p2, p3, p4, ncol=2)
p5 <- ggplot(data=ion.clim.ca, aes(x=PPT, y=Percent.Leaked)) +
  geom_point() + theme_bw() + xlab("Average Annual Precipitation") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p6 <- ggplot(data=ion.clim.ca, aes(x=tdmean, y=Percent.Leaked)) +
  geom_point() + theme_bw() + xlab("Average Annual Dew Point Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p7 <- ggplot(data=ion.clim.ca, aes(x=vpdmax, y=Percent.Leaked)) +
  geom_point() + theme_bw() + xlab("Average Max Annual Vapor Pressure Deficit") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p8 <- ggplot(data=ion.clim.ca, aes(x=vpdmin, y=Percent.Leaked)) +
  geom_point() + theme_bw() + xlab("Average Min Annual Vapor Pressure Deficit") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p9 <- ggplot(data=ion.clim.ca, aes(x=solclear, y=Percent.Leaked)) +
  geom_point() + theme_bw() + xlab("Average Annual Solar Radiation") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p10 <- ggplot(data=ion.clim.ca, aes(x=soltrans, y=Percent.Leaked)) +
  geom_point() + theme_bw() + xlab("Average Annual Cloud Transmittance") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
grid.arrange(p5, p6, p7, p8, p9, p10, ncol=3)
```

### PHENOTYPE DATA ###
Loading the data
```{r}
pheno <- read.csv("PhenotypeScores.csv")
pheno$Individual <- as.factor(pheno$Individual)
```

For californica only, run this chunk
```{r}
pheno.ca <- pheno %>%
  filter(Species == "californica")
```

For californica, arucata and retrofracta, run this chunk
```{r}
pheno.ca <- pheno %>%
  filter(Species == "californica" | Species == "arcuata" | Species == "retrofracta")
```

Creating a mean score for each subpop
```{r}
pheno.ca.1 <- pivot_longer(pheno.ca, cols = 2:4, names_to = "Time", values_to = "Score")
pheno.ca.2 <- aggregate(Score ~ PopID + Time, 
                    data=pheno.ca.1, 
                    function(x) { 
                      c(avg=mean(x)) 
                    })
pheno.ca.2$PopID <- as.factor(pheno.ca.2$PopID)
colnames(pheno.ca.2) <- c('PopID','Time','Score.pop.mean')
pheno.ca.2$Time <- factor(pheno.ca.2$Time, levels=c('Initial', 'poststress', 'postrecovery'))
```
Plotting averages
```{r}
phenoplot2 <- ggplot(data=pheno.ca.2, aes(x=Time, y=PopID,fill=Score.pop.mean)) +
  geom_tile(color="black", lwd=0.08) +
  scale_fill_gradient2(low="#318e1e", mid = "#ffff55", high="#ffffe9", 
                       midpoint = 1.5, na.value = "gray") +
  theme_ipsum(base_size=20) +
  ylab("Subpopulation") +
  xlab("Time") +
  labs(title = "Phenotype Score", fill= "Average Subpopulation Score") +
  scale_x_discrete(labels=c("Pre.Stress" = "Pre Stress", "Post.Stress" = "After Stress",
                            "Post.Recovery" = "After 5 Day Recovery"))
phenoplot2
```

Adding a variance column and binding to climate data
```{r}
#Create a new column with the variances of each individual
pheno.ca.3 <- aggregate(Score ~ Individual + Time, 
                    data=pheno.ca.1, 
                    function(x) { 
                      c(avg=var(x)) 
                    })
colnames(pheno.ca.3) <- c('Individual','Time','Score.var')
pheno.ca.3 <- left_join(pheno.ca.3, pheno.ca.1, by=c('Individual','Time'))
pheno.ca.3$Individual <- as.factor(pheno.ca.3$Individual)
pheno.ca.3 <- pheno.ca.3[!duplicated(pheno.ca.3[,c('Individual','Time')]), ]
pheno.ca.4 <- aggregate(Score ~ Individual + Time, 
                    data=pheno.ca.1, 
                    function(x) { 
                      c(avg=mean(x)) 
                    })
colnames(pheno.ca.4) <- c('Individual','Time','Score.mean')
pheno.ca.4 <- left_join(pheno.ca.3, pheno.ca.4, by=c('Individual','Time'))
pheno.ca.4$Individual <- as.factor(pheno.ca.4$Individual)
pheno.ca.4$PopID <- as.factor(pheno.ca.4$PopID)
pheno.ca.4 <- pheno.ca.4[,-7]
climate$Individual <- as.factor(climate$Individual)
pheno.clim.ca <- left_join(pheno.ca.4, climate, by=c("Individual","Region","PopID","Species"))
colnames(pheno.clim.ca) <- c('Individual','Time','Score.var','PopID','Region','Species','Score.mean','Latitude','Longitude','Elevation','Date.Found','tmean','tmax','tmin','PPT','tdmean','vpdmax','vpdmin','aspect','solclear','soltrans') #Renaming columns for legibility
```

to filter for only post recovery, run this chunk
```{r}
pheno.clim.ca <- pheno.clim.ca %>%
  filter(Time == "postrecovery")
```

Nested ANOVA to test the variance of Phenotype Score. 
The model is Score ~ Region + Pop(Region) + Individual(Pop(Region))
Individual is a random effect. 
```{r}
#Make the nested anova
nest_p <- aov(pheno.clim.ca$Score.mean ~ pheno.clim.ca$Region / factor(pheno.clim.ca$PopID) / factor(pheno.clim.ca$Individual))
summary(nest_p)
TukeyHSD(nest_p)$'pheno.clim.ca$Region'
```

ANOVA for diploids
```{r}
nest_p2 <- aov(pheno.clim.ca$Score.mean ~ pheno.clim.ca$Species)
summary(nest_p2)
TukeyHSD(nest_p2)
```

Linear Mixed Effects Model
```{r}
mixed.lmer_p <- lmer(Score.mean ~ Region + (1|Individual), data = pheno.clim.ca)
summary(mixed.lmer_p)
plot(mixed.lmer_p)
qqnorm(resid(mixed.lmer_p)); qqline(resid(mixed.lmer_p))
#Variance for Individual is 0.0. Divide this by total variance. 
0.0 / (0.0 + 0.794) # =0.0
#Individual explains 0% of the variance left over after the variance explained by our fixed effects.
```

Multiple Regression

Best Subsets to determine the model with the highest r squared value. 
```{r}
pmod.fit <- regsubsets(Score.mean ~ tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data=pheno.clim.ca, nvmax=10)
sum.pmod <- summary(pmod.fit)
sum.pmod
plot(sum.pmod$adjr2,xlab = "Number of Variables", ylab = "Adjusted RSq")
adj_r2_max = which.max(sum.pmod$adjr2) #7
points(adj_r2_max, sum.pmod$adjr2[adj_r2_max], col ="red", cex = 2, pch = 20)
```

Creating the multiple regression model
```{r}
pmod <- lm(Score.mean ~ tmean + Elevation + tmax + vpdmax + tmin + PPT + solclear, data=pheno.clim.ca)
summary(pmod) #adjusted r squared = 0.4359, p-value = 0.0002627
RSME.pmod <- sqrt(mean(pmod$residuals^2))
RSME.pmod
AIC(pmod);BIC(pmod)
```

Plotting leaf chlorosis against climatic variables
```{r}
p1 <- ggplot(data=pheno.clim.ca, aes(x=tmean, y=Score.mean)) +
  geom_point() + theme_bw() + xlab("Mean Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p2 <- ggplot(data=pheno.clim.ca, aes(x=tmax, y=Score.mean)) +
  geom_point() + theme_bw() + xlab("Average Max Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p3 <- ggplot(data=pheno.clim.ca, aes(x=tmin, y=Score.mean)) +
  geom_point() + theme_bw() + xlab("Average Min Annual Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p4 <- ggplot(data=pheno.clim.ca, aes(x=Elevation, y=Score.mean)) +
  geom_point() + theme_bw() +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
grid.arrange(p1, p2, p3, p4, ncol=2)
p5 <- ggplot(data=pheno.clim.ca, aes(x=PPT, y=Score.mean)) +
  geom_point() + theme_bw() + xlab("Average Annual Precipitation") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p6 <- ggplot(data=pheno.clim.ca, aes(x=tdmean, y=Score.mean)) +
  geom_point() + theme_bw() + xlab("Average Annual Dew Point Temperature") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p7 <- ggplot(data=pheno.clim.ca, aes(x=vpdmax, y=Score.mean)) +
  geom_point() + theme_bw() + xlab("Average Max Annual Vapor Pressure Deficit") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p8 <- ggplot(data=pheno.clim.ca, aes(x=vpdmin, y=Score.mean)) +
  geom_point() + theme_bw() + xlab("Average Min Annual Vapor Pressure Deficit") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p9 <- ggplot(data=pheno.clim.ca, aes(x=solclear, y=Score.mean)) +
  geom_point() + theme_bw() + xlab("Average Annual Solar Radiation") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
p10 <- ggplot(data=pheno.clim.ca, aes(x=soltrans, y=Score.mean)) +
  geom_point() + theme_bw() + xlab("Average Annual Cloud Transmittance") +
  geom_smooth(method="lm", alpha=0.3, linetype="longdash", color="#0072B2")
grid.arrange(p5, p6, p7, p8, p9, p10, ncol=3)
```







Finding climatic clusters

Creating a climate distance matrix
```{r}
dat1 <- read.csv("boechera_climate_data_msat_samples.csv", row.names=1)
#clim.msat$Individual<- as.factor(clim.msat$Individual)
head(dat1)
dat2 <- dat1[,-c(1)]
dat2 = data.frame(scale(dat2))
head(dat2)
```

Creating distance matrix using different methods
```{r}
euclid=dist(dat2, method ="euclidean")
euclid_sq=euclid^2
euclid_sqrt=sqrt(euclid)
library(ecodist)
braycurtis=distance(dat2, "bray-curtis")
mahal_sq=distance(dat2, "mahal")
hist(mahal_sq)
mahal=sqrt(mahal_sq)
#mahal # check how a distance matrix looks like
```

Convert to a dataframe to write it to a csv file if needed
```{r}
df.e <- as.data.frame(as.matrix(euclid))
write.csv(df.e, file="clim.euclid.csv")
```

Finding optimal K
```{r}
fviz_nbclust(dat2, FUNcluster=kmeans, method="wss")
fviz_nbclust(dat2, FUNcluster=kmeans, method="silhouette")
fviz_nbclust(dat2, FUNcluster=kmeans, method="gap_stat")
fviz_cluster(kmeans3, data=dat2, shape=1,
 show.clust.cent=T, ellipse.type="t",
 ellipse.level=0.7, ellipse.alpha=0.1,
 palette=c("pink3","yellow3","purple"),
 ggtheme=theme_classic(base_size=20))
#citation("factoextra")
```

Using K=3 to find groupings
```{r}
kmeans3=kmeans(euclid, centers=3, iter.max=50, nstart=25)
kmeans3$size; kmeans3$centers; kmeans3$cluster #Prints group membership
out1=metaMDS(euclid, k=3)
scores=out1$points[,1:2]
plot(scores, pch=19, size= 4, col=mycol[as.factor(kmeans3$cluster)])
text(scores+0.2, labels=PopID)
```



##Distance Matrices

Loading in Bruvo Genetic Distance Matrix
```{r}
bruv <- read.csv("BruvoDistMat.csv")
head(bruv)
rownames(bruv) <- bruv$X
bruv = bruv[,-1]
names(bruv) = gsub(pattern = "X", replacement = "", x = names(bruv))
bruv2 <- as.dist(bruv)
```

Loading in Pop Distance Matrix (meters)
```{r}
km <- read.table("bca_coords_km_mat.txt")
head(km)
names(km) = gsub(pattern = "X", replacement = "", x = names(km))
km2 <- as.dist(km)
```

Graphing genetic, climatic, and physical distances
```{r}
dist.df <- data.frame( Bruvo=bruv2[lower.tri(bruv2)], ClimDist=euclid[ lower.tri(euclid)], GeogDist = km2[lower.tri(km2)])
summary(dist.df)
distplot1 <- ggplot(dist.df,aes(x=ClimDist,y=Bruvo)) + 
  geom_point() +
  theme_bw(base_size=20) +
  xlab("Climate Distance") + ylab("Genetic Distance (Bruvo's)") +
  geom_smooth(method="lm", alpha=0.15, linetype="solid", color="#0072B2")
distplot1
distplot2 <- ggplot(dist.df,aes(x=GeogDist,y=Bruvo)) + 
  geom_point() +
  theme_bw(base_size=20) +
  xlab("Geographic Distance (kilometers)") + ylab("Genetic Distance (Bruvo's)") +
  geom_smooth(method="lm", alpha=0.15, linetype="solid", color="#0072B2")
distplot2
distplot3 <- ggplot(dist.df,aes(x=GeogDist,y=ClimDist)) + 
  geom_point() +
  theme_bw(base_size=20) +
  xlab("Geographic Distance (kilometers)") + ylab("Climatic Distance") +
  geom_smooth(method="lm", alpha=0.15, linetype="solid", color="#0072B2")
distplot3
```

Generalized linear models using distance matrices
```{r}
a <- glm(Bruvo ~ ClimDist, data=dist.df)
summary(a)
anova(a)
a2 <-glm(Bruvo ~ GeogDist, data=dist.df)
summary(a2)
anova(a2)
a3 <-glm(ClimDist ~ GeogDist, data=dist.df)
summary(a3)
anova(a3)
a4 <- glm(Bruvo ~ ClimDist + GeogDist, data=dist.df)
summary(a4)
anova(a4)
AIC(a);AIC(a2);AIC(a3);AIC(a4)
BIC(a);BIC(a2);BIC(a3);BIC(a4)
Dsquared(a, adjust=T);Dsquared(a2, adjust=T);Dsquared(a4, adjust=T)
```

Linear models
```{r}
a <- glm(Bruvo ~ ClimDist, data=dist.df)
summary(a)
anova(a)
a2 <-glm(Bruvo ~ GeogDist, data=dist.df)
summary(a2)
anova(a2)
a3 <-lm(ClimDist ~ GeogDist, data=dist.df)
summary(a3)
anova(a3)
a4 <- lm(Bruvo ~ ClimDist + GeogDist, data=dist.df)
summary(a4)
anova(a4)
AIC(a);AIC(a2);AIC(a3);AIC(a4)
BIC(a);BIC(a2);BIC(a3);BIC(a4)
#Dsquared(a, adjust=T);Dsquared(a2, adjust=T);Dsquared(a4, adjust=T)
cand.mods <- list("Climate" = a, "Geography" = a2)
selectionTable <- aictab(cand.set = cand.mods)
selectionTable
confset(cand.set = cand.mods)
```



Adding genetic diversity to YII recovery data
```{r}
popgen <- read.csv("popgendiversity.csv")
popgen$PopID <- as.factor(popgen$PopID)
pg <- left_join(recovery.clim.ca.3, popgen, by="PopID")
head(pg)
pg[19:28]<- scale(pg[19:28])
```

Bestsubset models using climate variables and genetic diversity variables. Should I maximize model predictability (adjusted R-squared) or model fit(AIC or BIC)?
```{r}
m1a <- regsubsets(YII ~ tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data=pg, nvmax=10)
sum.pmod <- summary(m1a)
sum.pmod
plot(sum.pmod$adjr2,xlab = "Number of Variables", ylab = "Adjusted RSq")
adj_r2_max = which.max(sum.pmod$adjr2) #9
points(adj_r2_max, sum.pmod$adjr2[adj_r2_max], col ="red", cex = 2, pch = 20)
m2a <- regsubsets(YII ~  MultlocFis + Eff_num + Ho + Hs + Gis, data=pg, nvmax=5)
sum.pmod <- summary(m2a)
sum.pmod
plot(sum.pmod$adjr2,xlab = "Number of Variables", ylab = "Adjusted RSq")
adj_r2_max = which.max(sum.pmod$adjr2) #4
points(adj_r2_max, sum.pmod$adjr2[adj_r2_max], col ="red", cex = 2, pch = 20)
m3a <- regsubsets(YII ~  MultlocFis + Eff_num + Ho + Hs + Gis + tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data=pg, nvmax=15)
sum.pmod <- summary(m3a)
sum.pmod
plot(sum.pmod$adjr2,xlab = "Number of Variables", ylab = "Adjusted Rsq")
adj_r2_max = which.max(sum.pmod$adjr2) #7
points(adj_r2_max, sum.pmod$adjr2[adj_r2_max], col ="red", cex = 2, pch = 20)
```

```{r}
m1 <- glm(YII ~ tmean + Elevation + tmax + tdmean + vpdmax + PPT + vpdmin + solclear + soltrans, data=pg)
summary(m1)
m2 <- glm(YII ~ MultlocFis + Eff_num + Ho + Hs + Gis, data=pg)
summary(m2)
m3 <- glm(YII~  Ho + Hs + Gis + Elevation + tmax + vpdmin + solclear, data=pg)
summary(m3)
Dsquared(m1, adjust=T);Dsquared(m2, adjust=T);Dsquared(m3, adjust=T)
```

```{r}
m1 <- glm(YII ~ tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data=pg)
summary(m1)
m2 <- glm(YII ~  MultlocFis + Eff_num + Ho + Hs + Gis, data=pg)
summary(m2)
m3 <- glm(YII ~  MultlocFis + Eff_num + Ho + Hs + Gis + tmean + Elevation + tmax + tdmean + vpdmax + tmin + PPT + vpdmin + solclear + soltrans, data=pg)
summary(m3)
Dsquared(m1, adjust=T);Dsquared(m2, adjust=T);Dsquared(m3, adjust=T)
```










Creating a YII distance matrix, based on recovery YII
```{r}
Y2 <- data.frame(recovery.clim.ca.2$Individual, recovery.clim.ca.2$PopID, recovery.clim.ca.2$YII, recovery.clim.ca.2$YII.mean, recovery.clim.ca.2$YII.var)
names(Y2) <- c("Individual", "PopID","YII","YII.mean","YII.var")
Y2$Individual <- as.factor(Y2$Individual)
#Y2a <- left_join(clusts, Y2, by=c("Individual","PopID"))
Y2b <- aggregate(YII ~ PopID, 
                    data=Y2, 
                    function(x) { 
                      c(avg=var(x)) 
                    })
Y2b
Y2d.stress <- dist(Y2b, method="euclidean")
#Y2d <- data.frame(as.matrix(Y2d.stress))
#write.csv(Y2d, "YII.pop.distance.csv")
#shapiro.test(Y2d.stress)
#hist(Y2d.stress)
#hist(sqrt(Y2d.stress))
```

Based on initial YII
```{r}
Y2 <- data.frame(stress.clim.ca.2$Individual, stress.clim.ca.2$PopID, stress.clim.ca.2$YII)
names(Y2) <- c("Individual", "PopID","YII")
Y2$Individual <- as.factor(Y2$Individual)
Y2b <- aggregate(YII ~ PopID, 
                    data=Y2, 
                    function(x) { 
                      c(avg=mean(x)) 
                    })
Y2b
Y2d.stress <- dist(Y2b, method="euclidean")
#shapiro.test(Y2d.stress)
#hist(Y2d.stress)
```

Based on ion leakage
```{r}
Ion <- data.frame(ion.clim.ca$Individual, ion.clim.ca$PopID, ion.clim.ca$Percent.Leaked)
names(Ion) <- c("Individual", "PopID","Ions")
Ion2 <- aggregate(Ions ~ PopID, 
                    data=Ion, 
                    function(x) { 
                      c(avg=mean(x)) 
                    })
Ion2
Ion2 <- Ion2[-3,]
Ion.dist <- dist(Ion2, method="euclidean")
```




Creating a gentetic matrix of the same size based on Nei's G
```{r}
ngpop <- read.csv("NeiGpopdist.csv")
rownames(ngpop) <- ngpop$X
ngpop <- ngpop[,-1]
#Run this part for no pop 5
ngpop <- ngpop[,-3]
ngpop <- ngpop[-3,]
head(ngpop)
ngpop2 <- as.dist(ngpop)
```

Creating a genetic distance matrix based on Rho
```{r}
ngpop <- read.csv("Rhopopdist.csv")
rownames(ngpop) <- ngpop$X
ngpop <- ngpop[,-1]
head(ngpop)
#Run this part for no pop 5
ngpop <- ngpop[,-3]
ngpop <- ngpop[-3,]
ngpop2 <- as.dist(ngpop)
```

New Nei G dist matrix
```{r}
ngpop <- read.csv("NeiGpopdist2.csv")
rownames(ngpop) <- ngpop$X
ngpop <- ngpop[,-1]
ngpop2 <- as.dist(ngpop)
```

Jost D genetic matrix
```{r}
ngpop <- read.csv("geneticjostdpop.csv")
rownames(ngpop) <- ngpop$X
ngpop <- ngpop[,-1]
ngpop2 <- as.dist(ngpop)
```



Creating a genetic distance matrix based on euclidean distances
```{r}
ngpop <- read.csv("geneticeuclidpop.csv")
rownames(ngpop) <- ngpop$X
ngpop <- ngpop[,-1]
head(ngpop)
#Run this part for no pop 5
ngpop <- ngpop[,-3]
ngpop <- ngpop[-3,]
ngpop2 <- as.dist(ngpop)
```

Creating a climate matrix the same size
```{r}
dat3 <- dat2[-c(2,4,5,7,8,10:13,15,16,18:20,22:24,26,28:30,32,34:36,39,40,42,44:46,48,50:54),] #pops only
dat3 <- dat3[-c(12,14,18),]
head(dat3)
dat3 <- scale(dat3)
# to remove pop 5
dat3 <- dat3[-3,]
#hist(dat3)
euclid.clim.subset=dist(dat3, method ="euclidean")
#climd <- data.frame(as.matrix(euclid.clim.subset))
#write.csv(climd, "climpopdist.csv")
```

Creating a physical distance matrix the same size
```{r}
km.subset <- read.table("bpop_km_subset.txt")
names(km.subset) = gsub(pattern = "X", replacement = "", x = names(km.subset))
head(km.subset)
#To remove pop 5
km.subset <- km.subset[,-3]
km.subset <- km.subset[-3,]
km.subset.d <- as.dist(km.subset)
```

Creating a mahal distance climate matrix
```{r}
mahal_sq=distance(dat3, "mahalanobis")
mahal=sqrt(mahal_sq)
```

```{r}
hist(mahal_sq)
hist(ngpop2)
hist(euclid.clim.subset)
hist(Y2d.stress)
```

Sqrt transforming everything
```{r}
ngpop2 <- sqrt(ngpop2)
euclid.clim.subset <- sqrt(euclid.clim.subset)
km.subset.d <- sqrt(km.subset.d)
Y2d.stress <- sqrt(Y2d.stress)
```

log transforming everything
```{r}
ngpop2 <- log(ngpop2)
euclid.clim.subset <- log(euclid.clim.subset)
km.subset.d <- log(km.subset.d)
Y2d.stress <-  log(Y2d.stress)
```

```{r}
head(ngpop2)
head(euclid.clim.subset)
head(km.subset.d)
head(Y2d.stress)
```

Multiple regression on distance matrices
```{r}
library(ecodist)
MRM(Y2d.stress ~ ngpop2 + mahal_sq + km.subset.d, nperm=1000, method="linear", mrank=F)
MRM(Y2d.stress ~ ngpop2 + euclid.clim.subset + km.subset.d, nperm=1000, method="linear", mrank=F)
MRM(Y2d.stress ~ ngpop2, nperm=1000, method="linear", mrank=F)
MRM(Y2d.stress ~ euclid.clim.subset, nperm=1000, method="linear", mrank=F)
MRM(Y2d.stress ~ km.subset.d, nperm=1000, method="linear", mrank=F)
MRM(Y2d.stress ~ mahal_sq, nperm=1000, method="linear", mrank=F)

AIC(MRM1)
MRM(Ion.dist ~ ngpop2 + mahal_sq + km.subset.d, nperm=1000, method="linear", mrank=F)
MRM(Ion.dist ~ km.subset.d, nperm=1000, method="linear", mrank=FALSE)
```






Creating the distance matrix dataframe with YII
```{r}
dist.df2 <- data.frame( GenDist=ngpop2[lower.tri(ngpop2)], ClimDist=euclid.clim.subset[ lower.tri(euclid.clim.subset)], GeogDist = km.subset.d[lower.tri(km.subset.d)], Stress = Y2d.stress[lower.tri(Y2d.stress)])
```
Creating the distance matrix dataframe with Ion Leakage
```{r}
dist.df2 <- data.frame( GenDist=ngpop2[lower.tri(ngpop2)], ClimDist=euclid.clim.subset[ lower.tri(euclid.clim.subset)], GeogDist = km.subset.d[lower.tri(km.subset.d)], Stress = Ion.dist[lower.tri(Ion.dist)])
```


```{r}
M1a <-glm(Stress ~ ClimDist, data=dist.df2)
M1b <-glm(Stress ~ GeogDist, data=dist.df2)
M1c <-glm(Stress ~ GenDist, data=dist.df2)
cand.mods <- list("Climate" = M1a, "Geography" = M1b, "Genetic" = M1c)
selectionTable <- aictab(cand.set = cand.mods)
selectionTable
#confset(cand.set = cand.mods)
Dsquared(M1a);Dsquared(M1b);Dsquared(M1c)
```
Root mean squared error
```{r}
RSME.M1a <- sqrt(mean(M1a$residuals^2))
RSME.M1a
RSME.M1b <- sqrt(mean(M1b$residuals^2))
RSME.M1b
RSME.M1c <- sqrt(mean(M1c$residuals^2))
RSME.M1c
```

```{r}
M2a <-glm(Stress ~ GenDist + ClimDist, data=dist.df2)
M2b <-glm(Stress ~ GenDist + GeogDist, data=dist.df2)
M2c <-glm(Stress ~ ClimDist + GeogDist, data=dist.df2)
M3 <- glm(Stress ~ ClimDist + GeogDist + GenDist, data=dist.df2)
Dsquared(M1a);Dsquared(M1b);Dsquared(M1c)
Dsquared(M2a);Dsquared(M2b);Dsquared(M2c)
Dsquared(M3)
#AIC(M1a);AIC(M1b);AIC(M1c)
#AIC(M2a);AIC(M2b);AIC(M2c);AIC(M3)
```






```{r}
M1a <- lm(Stress ~ ClimDist, data=dist.df2)
M1b <-lm(Stress ~ GeogDist, data=dist.df2)
M1c <-lm(Stress ~ GenDist, data=dist.df2)
summary(M1a);summary(M1b);summary(M1c)
summary(M1a)$adj.r.squared
AIC(M1a);AIC(M1b);AIC(M1c)
BIC(M1a);BIC(M1b);BIC(M1c)
cand.mods <- list("Climate" = M1a, "Geography" = M1b, "Genetic" = M1c)
selectionTable <- aictab(cand.set = cand.mods)
selectionTable
confset(cand.set = cand.mods)
```


```{r}
dplot1 <- ggplot(dist.df2, aes(x=ClimDist, y=Stress)) +
  geom_point() +
  theme_bw(base_size=10) +
  xlab("Climate") + ylab("Stress") +
  geom_smooth(method="lm", alpha=0.15, linetype="solid", color="#0072B2")
dplot1
dplot2 <- ggplot(dist.df2, aes(x=GeogDist, y=Stress)) +
  geom_point() +
  theme_bw(base_size=10) +
  xlab("Climate") + ylab("Stress") +
  geom_smooth(method="lm", alpha=0.15, linetype="solid", color="#0072B2")
dplot2
dplot3 <- ggplot(dist.df2, aes(x=GenDist, y=Stress)) +
  geom_point() +
  theme_bw(base_size=10) +
  xlab("Genetic Distance") + ylab("Stress") +
  geom_smooth(method="lm", alpha=0.15, linetype="solid", color="#0072B2")
dplot3
```














AICc scores for clusters
```{r}
adegenetTutorial("snapclust")
library(adegenet)
data(dapcIllus)
sapply(dapcIllus, nPop)
dapcIllus
a.clust <- snapclust(dapcIllus$a, k = 6)
class(a.clust)
names(a.clust)
head(a.clust$group, 12)
length(a.clust$group)
dim(a.clust$proba)
head(a.clust$proba)
a.tab <- table(pop(dapcIllus$a), a.clust$group)
a.tab
class(a.tab)
```

```{r}
cal <- read.genalex("msat_genalex_californica.csv", ploidy=4, geo=FALSE)
cal2 <- genclone2genind(cal)
cal2
class(cal2)
sapply(cal2, nPop)
AICc(a.clust, 3, pop.ini = "ward",
  max.iter = 100,
  n.start = 10,
  n.start.kmeans = 50,
  hybrids = FALSE,
  dim.ini = 100,
  hybrid.coef = NULL,
)
```

```{r}
obj1 <- read.structure("Msat_ca_triploid_missingalleles", n.ind=55, n.loc=13, row.marknames=1)

```

```{r}
gendf1<- read.csv("msatdf_trip_missingmarkers.csv")
rownames(gendf1) <- gendf1[,1]; gendf1 <- gendf1[,-c(1)]
gendf2 <- t(gendf1)
obj1 <- df2genind(gendf1, sep=",", ncode=3, NA.char=0, ploidy=2, type='codom')
obj1
sapply(obj1, pop)
```

```{r}
a.clust <- snapclust(obj1, k = 2)

a.tab <- read.csv("Structuregroups.csv")
head(a.tab)
a.tab <- a.tab[-1,]
a.tab <- as.table(a.tab)
```

```{r}
find.clusters.genind(obj1)
```


```{r}
a.clust
AICc(a.clust, 2, pop.ini = "ward",
  max.iter = 100,
  n.start = 10,
  n.start.kmeans = 50,
  hybrids = FALSE,
  dim.ini = 100,
  hybrid.coef = NULL,
)

```
































